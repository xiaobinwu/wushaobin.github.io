<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="24k-小清新个人技术博客"><meta name="keywords" content="Hexo, GulpJs, Nodejs, Reactjs, Vuejs, Javascript, 前端"><title>canvas绘图基础 - 前端穷屌丝，爱码人士</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/xiaobinwu"><span>Github</span></a></li><li><a href="http://www.cnblogs.com/wuxiaobin/"><span>博客园</span></a></li><li><a href="/atom.xml"><span>RSS</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">canvas绘图基础</h1><ul class="meta"><li><i class="icon icon-author"></i>24k-小清新</li><li><i class="icon icon-clock"></i>23 Minutes</li><li><i class="icon icon-calendar"></i>2015年10月28日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>&lt;canvas&gt;元素是HTML5中的绘图元素，通过定义一个画布区域，然后使用javascript动态地在这个区域里面绘制图形，对于2D和3D图形都可以绘制，我们将其分成2D上下文和WebGL两大块内容来一起来学习，但是WebGL觉得比较少用到，而且难，所以不讲了！<br>一、了解canvas<br>&lt;canvas  id=&lsquo;draw&rsquo; width=&lsquo;200&rsquo; height=&lsquo;200’ &gt; nothing &lt;/canvas&gt;，这是便是一个基本canvas元素的写法了，但是我们必须通过javascript来动态获得，那么需要这样：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ea4ad5dd-d0fb-46d1-8f93-d11c8dc77be8')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_ea4ad5dd-d0fb-46d1-8f93-d11c8dc77be8" class="cnblogs_code_hide"><br><pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">var</span> draw =<span style="color: #000000;"> document.getElementById(&lsquo;draw&rsquo;);<br></span><span style="color: #008080;"> 2</span> <span style="color: #008000;">//</span><span style="color: #008000;">确定是否支持canvas</span><br><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(draw.getContext){<br></span><span style="color: #008080;"> 4</span> <span style="color: #008000;">//</span><span style="color: #008000;">这样就取得绘图上下文对象的引用，画图便可以开始了！</span><br><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">var</span> context =<span style="color: #000000;"> draw.getContext(&lsquo;2d&rsquo;);<br></span><span style="color: #008080;"> 6</span> <span style="color: #008000;">//</span><span style="color: #008000;">取得图像的数据uri，显示图像</span><br><span style="color: #008080;"> 7</span> <span style="color: #0000ff;">var</span> imageuri = draw.toDataURL(&lsquo;image/<span style="color: #000000;">png&rsquo;);<br></span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">var</span> img =<span style="color: #000000;"> document.createElement(&lsquo;img&rsquo;);<br></span><span style="color: #008080;"> 9</span> img.src=<span style="color: #000000;"> imageuri;<br></span><span style="color: #008080;">10</span> <span style="color: #000000;">document.body.appendChild(img);<br></span><span style="color: #008080;">11</span> }</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p>二、2D上下文<br>对于2D上下文的坐标是开始于canvas元素的左上角的，原点的坐标为(0，0)，x轴越往右越大，y轴越往下越大就算但画布的原坐标发生translate也不例外，如下图：</p>
<p><strong>填充</strong>（使用指定样式［颜色、渐变、图像、模式等］填充图形）和<strong>描边</strong>（图形的边缘画线）分别为fillStyle和strokeStyle，需要注意一点，fillStyle和strokeStyle会被延用至重新设置这两个值！</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b87fd0b3-e36c-432d-8ffb-3b709b8e142e')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_b87fd0b3-e36c-432d-8ffb-3b709b8e142e" class="cnblogs_code_hide"><br><pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> draw =<span style="color: #000000;"> document.getElementById(&lsquo;draw&rsquo;);<br></span><span style="color: #008080;">2</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(draw.getContext){<br></span><span style="color: #008080;">3</span> <span style="color: #0000ff;">var</span> context =<span style="color: #000000;"> draw.getContext(&lsquo;2d&rsquo;);<br></span><span style="color: #008080;">4</span> context.strokeStyle = &ldquo;#<span style="color: #800080;">000</span><span style="color: #000000;">&rdquo;;<br></span><span style="color: #008080;">5</span> context.fillStyle =<span style="color: #000000;"> &lsquo;#0000ff&rsquo;;<br></span><span style="color: #008080;">6</span> }</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p><strong>绘制矩形</strong>，有以下方法fillRect()、strokeRect()、clearRect()的方法，都是一样的，传入四个参数，矩形的x坐标、矩形的y坐标、矩形的宽度width、矩形的高度height，</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4b8c201a-f350-4d85-8bec-9c9370dc5d07')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_4b8c201a-f350-4d85-8bec-9c9370dc5d07" class="cnblogs_code_hide"><br><pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">var</span> draw =<span style="color: #000000;"> document.getElementById(&lsquo;draw&rsquo;);<br></span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(draw.getContext){<br></span><span style="color: #008080;"> 3</span><br><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">var</span> context =<span style="color: #000000;"> draw.getContext(&lsquo;2d&rsquo;);<br></span><span style="color: #008080;"> 5</span> <span style="color: #008000;">//</span><span style="color: #008000;">绘制黑色矩形</span><br><span style="color: #008080;"> 6</span> context.strokeStyle = &ldquo;#<span style="color: #800080;">000</span><span style="color: #000000;">&rdquo;;<br></span><span style="color: #008080;"> 7</span> context.strokeRect(<span style="color: #800080;">10</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">50</span><span style="color: #000000;">);<br></span><span style="color: #008080;"> 8</span> <span style="color: #008000;">//</span><span style="color: #008000;">绘制黑色矩形</span><br><span style="color: #008080;"> 9</span> context.strokeStyle = &ldquo;#<span style="color: #800080;">000</span><span style="color: #000000;">&rdquo;;<br></span><span style="color: #008080;">10</span> context.fillRect(<span style="color: #800080;">30</span>,<span style="color: #800080;">30</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">50</span><span style="color: #000000;">);<br></span><span style="color: #008080;">11</span><br><span style="color: #008080;">12</span> <span style="color: #008000;">//</span><span style="color: #008000;">在两个填充矩形重叠的地方清除一个小矩形</span><br><span style="color: #008080;">13</span> context.clearRect(<span style="color: #800080;">40</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">10</span><span style="color: #000000;">);<br></span><span style="color: #008080;">14</span><br><span style="color: #008080;">15</span> <span style="color: #008000;">//</span><span style="color: #008000;">绘制描边矩形</span><br><span style="color: #008080;">16</span> context.fillStyle =<span style="color: #000000;"> &lsquo;#0000ff&rsquo;;<br></span><span style="color: #008080;">17</span> context.fillRect(<span style="color: #800080;">30</span>,<span style="color: #800080;">30</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">50</span><span style="color: #000000;">);<br></span><span style="color: #008080;">18</span><br><span style="color: #008080;">19</span> }</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p><strong>绘制路径</strong>，2d上下文有很多在画布上绘制路径的方法，可以创造出复杂的形状和线条。要绘制路径，首先需要调用beginPath()方法，<br>arc(x,y,radius,startAngle,endAngle,counterclockwise)，意思是以(x,y)为圆心，radius为半径，counterclockwise的值为false的时候顺时针画圆（或圆弧），开始角度startAngle，结束角度endAngle，用弧度表示；<br>arcTo(x1,y1,x,y,radius)，意思是从(x1,y1)到(x,y)，以radius为半径，画一条弧线；<br>lineTo(x,y)，意思是从上一个点画一条直线至(x,y)；<br>moveTo(x,y)，意思是将绘图的游标移至(x,y)，也就是从此点开始绘制；<br>rect(x,y,width,height)，这是画个矩形，就不多说了；<br>bezierCurveTo(x1,y1,x2,y2,x,y)，意思从上一个点开始，是以(x1,y1)、(x2,y2)为控制点，(x,y)为终点的三次贝尔塞曲线；</p>
<p>quadraticCurveTo(cx,cy,x,y)，意思是从上一个点开始，是以(cx,cy)为控制点，(x,y)为终点的二次贝尔塞曲线。</p>
<p>那么接下来，创建路径之后，我们可以又怎么这几种选择：</p>
<p>使用closePath()，关闭路径，绘制一条连接至起点的线条；</p>
<p>使用fill()、stroke()，对路径进行填充或是描边，前提是设置了（fillStyle、strokeStyle）</p>
<p>使用clip()，创建一个剪切区域</p>
<p>如果我们想在路径关闭之前，判断某个点是否在路径上，可以这样来做</p>
<div class="cnblogs_code"><br><pre><span style="color: #0000ff;">if</span>(context.isPointInPath(<span style="color: #800080;">100</span>,<span style="color: #800080;">100</span><span style="color: #000000;">)){<br>    alert(</span><span style="color: #800000;">“</span><span style="color: #800000;">点击这里<a href="http://t.cn/RUbL4rP" target="_blank" rel="external">http://t.cn/RUbL4rP</a>，就可以跳转，快来看看阿！</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>}</span></pre><br></div>

<p><strong>&nbsp;绘制文本</strong>，有图，就有文本，主要有两个方法，fillText()和strokeText(),传入四个参数，str（字符串）、x坐标、y坐标、最大像素宽度(超过此值，将会自动收缩)，当然这两个方法是以以下三个属性（font、textAlign、textBaseline）为基础的，当然要注意，这两个方法也是使用fillStyle和strokeStyle来做填充和描边滴，之后也有demo更新到github上面去!</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('77343626-a58d-460b-a72c-5e91c2d707f1')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_77343626-a58d-460b-a72c-5e91c2d707f1" class="cnblogs_code_hide"><br><pre>context.font=<span style="color: #800000;">“</span><span style="color: #800000;">blod 14px Arial</span><span style="color: #800000;">“</span><span style="color: #000000;">;<br>context.textAlign </span>= <span style="color: #800000;">“</span><span style="color: #800000;">center</span><span style="color: #800000;">“</span>;<span style="color: #008000;">//</span><span style="color: #008000;">“start” “end” “left” “right”</span><br>context.textBaseline = <span style="color: #800000;">“</span><span style="color: #800000;">middle</span><span style="color: #800000;">“</span>;<span style="color: #008000;">//</span><span style="color: #008000;">“top” “bottom” “hanging” “alphabetic”  “ideographic”</span><br><span style="color: #000000;"><br>context.fillText(</span><span style="color: #800000;">“</span><span style="color: #800000;">工资低，被迫下海，还望大家多多支持，多多棒槌，宣传一下下</span><span style="color: #800000;">“</span>,<span style="color: #800080;">100</span>,<span style="color: #800080;">20</span>);</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p>有时候，我们需要将我们的文本控制在某一个区域中的时候，那么会用到measureText()方法，传入一个参数（我们需要显示的字符串），得到的对象里面有个width属性，返回最佳的width，假如说我们现在想在width=150px的画布上显示合适的字体的话，可以这样</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('54efb591-52df-499e-9de6-62699884ea3c')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_54efb591-52df-499e-9de6-62699884ea3c" class="cnblogs_code_hide"><br><pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> font_size =<span style="color: #000000;"> 40px;<br></span><span style="color: #008080;">2</span> context.font = font_size+<span style="color: #800000;">‘’</span>px arial<span style="color: #800000;">“</span><span style="color: #800000;">;</span><br><span style="color: #008080;">3</span> <span style="color: #0000ff;">while</span>(context.measureText(<span style="color: #800000;">“</span><span style="color: #800000;">工资低，被迫下海，还望大家多多支持，多多棒槌，宣传一下下</span><span style="color: #800000;">“</span>)&gt;<span style="color: #000000;">600px){<br></span><span style="color: #008080;">4</span>       font_size–<span style="color: #000000;">;<br></span><span style="color: #008080;">5</span>       context.font = font_size+<span style="color: #800000;">‘’</span>px arial<span style="color: #800000;">“</span><span style="color: #800000;">;         </span><br><span style="color: #008080;">6</span> <span style="color: #000000;">}<br></span><span style="color: #008080;">7</span> context.fillText(<span style="color: #800000;">“</span><span style="color: #800000;">工资低，被迫下海，还望大家多多支持，多多棒槌，宣传一下下</span><span style="color: #800000;">“</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">10</span>);</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p><strong>绘制变换</strong>，即是如css3中transform变换，创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵中下，所有处理是直接绘制。有如下这些变化：</p>
<p>rotate(angle);//angle是弧度</p>
<p>scale(x1,y1);//放大缩小，在x方向乘以x1，在y方向乘以y1</p>
<p>translate(x,y);//将坐标原点移动到(x,y)，好了(x,y)它就变成原点了</p>
<p>transform(m1_1,m1_2,m2_1,m2_2,dx,dy);//直接改变矩阵</p>
<p>setTransform(m1_1,m1_2,m2_1,m2_2,dx,dy);//设置矩阵，对于矩阵详解：<a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-矩阵/" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-矩阵/</a></p>
<p>排列方式：<img src="http://images2015.cnblogs.com/blog/720690/201510/720690-20151027182139216-1775561950.png" alt="">，其对应的排列方式是这样的，与transform: matrix(a,b,c,d,e,f);还是不一样滴！</p>
<p><strong>绘制图像</strong>，把一副图像绘制到画布上，，可以使用drawImage()方法，可以这样</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5ee55c50-a929-44c9-a7fa-d7cbdd233b1b')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_5ee55c50-a929-44c9-a7fa-d7cbdd233b1b" class="cnblogs_code_hide"><br><pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> image = document.images[<span style="color: #800080;">0</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">获取文档中第一张图像</span><br><span style="color: #008080;">2</span> context.drawImge(image,x,y,width,height,rx,ry,rwidth,rheight);<span style="color: #008000;">//</span><span style="color: #008000;">各个参数分别是：image图像对象，源图像的x坐标、源图像的y坐标，源图像的宽度，源图像的高度，目标图像的x坐标，目标图像的y坐标，目标图像的宽度，目标图像的高度，一般只需要前五个参数，就可以画出一个图像出来了！<br></span><span style="color: #008080;">3</span><br><span style="color: #008080;">4</span> <span style="color: #008000;">//</span><span style="color: #008000;">可以怎么理解，如context.drawImage(image,0,10,50,50,0,100,40,60);原始图像是以(0,10)为起点，高宽都为50px，但我们想要它实际显示在(0,100),宽40，高60，感觉实际上并没什么用</span></pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p><strong>&nbsp;阴影，</strong>有以下这几个属性:</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e8be5e33-a5dc-4dcd-b4ec-e56697d2fdea')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_e8be5e33-a5dc-4dcd-b4ec-e56697d2fdea" class="cnblogs_code_hide"><br><pre><span style="color: #0000ff;">var</span> context = drawing.getContext(<span style="color: #800000;">‘</span><span style="color: #800000;">2d</span><span style="color: #800000;">‘</span><span style="color: #000000;">);<br>context.shadowColor </span>= <span style="color: #800000;">“</span><span style="color: #800000;">#000</span><span style="color: #800000;">“</span>;<span style="color: #008000;">//</span><span style="color: #008000;">阴影颜色</span><br>context.shadowOffsetX = <span style="color: #800080;">5</span>;<span style="color: #008000;">//</span><span style="color: #008000;">阴影x的偏移量</span><br>context.shadowOffsetX = <span style="color: #800080;">5</span>;<span style="color: #008000;">//</span><span style="color: #008000;">阴影y的偏移量</span><br>context.shadowBlur = <span style="color: #800080;">4</span>;<span style="color: #008000;">//</span><span style="color: #008000;">阴影的模糊距离</span></pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p><strong>&nbsp;渐变</strong>，分为线性渐变和径祥渐变，分别是createLinearGradient()和createRadialGradient()，使用如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5381a026-a0a3-4503-995f-b43b2aa0789d')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_5381a026-a0a3-4503-995f-b43b2aa0789d" class="cnblogs_code_hide"><br><pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">var</span> gradient = context.createLinearGradient(<span style="color: #800080;">30</span>,<span style="color: #800080;">30</span>,<span style="color: #800080;">70</span>,<span style="color: #800080;">70</span>);<span style="color: #008000;">//</span><span style="color: #008000;">创建一个线性渐变区域,矩形区域，要使渐变覆盖整个矩形，需要有时还需要匹配一下坐标</span><br><span style="color: #008080;"> 2</span><br><span style="color: #008080;"> 3</span> gradient.addColorStop(<span style="color: #800080;">0</span>,<span style="color: #800000;">“</span><span style="color: #800000;">white</span><span style="color: #800000;">“</span>); <span style="color: #008000;">//</span><span style="color: #008000;">创建色标的开始位置信息</span><br><span style="color: #008080;"> 4</span><br><span style="color: #008080;"> 5</span> gradient.addColorStop(<span style="color: #800080;">1</span>,<span style="color: #800000;">“</span><span style="color: #800000;">black</span><span style="color: #800000;">“</span>);<span style="color: #008000;">//</span><span style="color: #008000;">创建色标的结束位置信息</span><br><span style="color: #008080;"> 6</span><br><span style="color: #008080;"> 7</span> context.fillStyle=<span style="color: #000000;"> gradient;<br></span><span style="color: #008080;"> 8</span><br><span style="color: #008080;"> 9</span> conetxt.fillRect(<span style="color: #800080;">30</span>,<span style="color: #800080;">30</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">40</span><span style="color: #000000;">);<br></span><span style="color: #008080;">10</span><br><span style="color: #008080;">11</span><br><span style="color: #008080;">12</span><br><span style="color: #008080;">13</span> <span style="color: #0000ff;">var</span> gradient = context.createRadialGradient(<span style="color: #800080;">50</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">30</span>);<span style="color: #008000;">//</span><span style="color: #008000;">创建一个径向渐变区域，这里是由两个同心圆组成的，(50,50)为圆的中心点，一个半径为10，一个半径为30，便可以向外扩散，形成径向渐变了</span><br><span style="color: #008080;">14</span><br><span style="color: #008080;">15</span> gradient.addColorStop(<span style="color: #800080;">0</span>,<span style="color: #800000;">“</span><span style="color: #800000;">white</span><span style="color: #800000;">“</span>); <span style="color: #008000;">//</span><span style="color: #008000;">创建色标的开始位置信息</span><br><span style="color: #008080;">16</span><br><span style="color: #008080;">17</span> gradient.addColorStop(<span style="color: #800080;">1</span>,<span style="color: #800000;">“</span><span style="color: #800000;">black</span><span style="color: #800000;">“</span>);<span style="color: #008000;">//</span><span style="color: #008000;">创建色标的结束位置信息</span><br><span style="color: #008080;">18</span><br><span style="color: #008080;">19</span> context.fillStyle=<span style="color: #000000;"> gradient;<br></span><span style="color: #008080;">20</span><br><span style="color: #008080;">21</span> conetxt.fillRect(<span style="color: #800080;">30</span>,<span style="color: #800080;">30</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">40</span>);</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p><strong>&nbsp;模式</strong>，意思就是重复的图像来填充画布了，也可以叫做纹理填充，一般使用的方法createPattern，使用如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5957ed76-951d-4a03-b56b-42f4bd10bd91')"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><br><div id="cnblogs_code_open_5957ed76-951d-4a03-b56b-42f4bd10bd91" class="cnblogs_code_hide"><br><pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">var</span> image = document.images[<span style="color: #800080;">0</span><span style="color: #000000;">];<br></span><span style="color: #008080;">2</span><br><span style="color: #008080;">3</span> <span style="color: #0000ff;">var</span> pattern= context.createPattern(image,<span style="color: #800000;">‘</span><span style="color: #800000;">repeat</span><span style="color: #800000;">‘</span>);<span style="color: #008000;">//</span><span style="color: #008000;">对应有repeat、repeat-x、repeat-y、no-repeat</span><br><span style="color: #008080;">4</span><br><span style="color: #008080;">5</span> context.fillStyle =<span style="color: #000000;"> pattern;<br></span><span style="color: #008080;">6</span><br><span style="color: #008080;">7</span> conetext.fillRect(<span style="color: #800080;">10</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">150</span>,<span style="color: #800080;">150</span>);</pre><br></div><br><span class="cnblogs_code_collapse">View Code</span></div>

<p>对于canvas绘图的基础就差不多怎么多了，以后还需努力学习，将其用在实际项目上，而对于webGL这种3d上下文就暂时不去学习，这几天看得晕晕的，感觉目前对自己也没什么用处！</p>
<p>&nbsp;</p>
</div><div class="article-meta" style="max-width:800px"></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj7ju58pn000o34p2yawye34n" data-title="canvas绘图基础" data-url="http://yoursite.com/2015/10/28/canvas绘图基础/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2015/10/20/如何自定义滚动条？/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2015/10/31/移动web技能总结/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/xiaobinwu" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/u/2379094031" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="Mailto:739288994@qq.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul><div class="site"><span>本站总访问量</span><span id="busuanzi_value_site_pv"></span><span>次，访客数</span><span id="busuanzi_value_site_uv"></span><span>人次</span></div></div><div class="bottom"><p class="copyright">© 2017 前端穷屌丝，爱码人士<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>